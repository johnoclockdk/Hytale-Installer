#!/bin/bash
set -e

# ================= COLORS =================
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color
# =========================================

# ================= CONFIG =================
USER_NAME=$(whoami)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BASE_DIR="$SCRIPT_DIR/hytale_server"
TOOLS_DIR="$SCRIPT_DIR/.hytale-tools"
TEMP_DIR="$SCRIPT_DIR/.hytale-temp"
BACKUP_DIR="$BASE_DIR/backups"
PID_FILE="$SCRIPT_DIR/.hytale-server.pid"
DOWNLOADER_URL="https://downloader.hytale.com/hytale-downloader.zip"
RESTART_CRON="0 0 */3 * * $(realpath $0) restart > /dev/null 2>&1" # Every 3 days at midnight
BACKUP_CRON="0 1 * * * $(realpath $0) backup > /dev/null 2>&1" # Daily at 1:00 AM
AUTOSTART_CRON="@reboot sleep 30 && $(realpath $0) start --skip-auth > /dev/null 2>&1" # Start on boot
BACKUP_RETENTION=7
PORT=5520
MIN_DISK_SPACE_MB=5120  # 5 GB minimum
AUTH_WAIT_TIMEOUT=120   # 2 minutes for auth URL
MODS_DIR="$BASE_DIR/mods"
# =========================================

# ================= MODS LIST =================
# Define available mods with their download URLs
# Mod filenames will be automatically set to <mod-name>.jar
declare -A MOD_URLS=(
  ["BetterMap"]="https://www.curseforge.com/api/v1/mods/1430352/files/7501446/download"
  ["EyeSpy"]="https://www.curseforge.com/api/v1/mods/1430352/files/7501446/download"
  ["Ymmersive_Melodies"]="https://www.curseforge.com/api/v1/mods/1430352/files/7501446/download"
  ["Miners_Helmet"]="https://www.curseforge.com/api/v1/mods/1430352/files/7501446/download"
  ["Simple_Claims"]="https://www.curseforge.com/api/v1/mods/1430352/files/7501446/download"
)
# =========================================

# ================= VALIDATION & HELPER FUNCTIONS =================

# Validate port number
validate_port() {
  local port=$1
  if ! [[ "$port" =~ ^[0-9]+$ ]]; then
    echo -e "${RED}Error: Port must be a number${NC}" >&2
    return 1
  fi
  
  if [ "$port" -lt 1024 ] || [ "$port" -gt 65535 ]; then
    echo -e "${RED}Error: Port must be between 1024 and 65535${NC}" >&2
    return 1
  fi
  
  return 0
}

# Check available disk space
check_disk_space() {
  local required_mb=$1
  local path=${2:-.}
  
  echo -e "${BLUE}Checking available disk space...${NC}"
  
  local available_mb=$(df -BM "$path" | awk 'NR==2 {print $4}' | sed 's/M//')
  
  if [ "$available_mb" -lt "$required_mb" ]; then
    echo -e "${RED}ERROR: Insufficient disk space${NC}" >&2
    echo -e "${YELLOW}Required: ${required_mb} MB${NC}" >&2
    echo -e "${YELLOW}Available: ${available_mb} MB${NC}" >&2
    echo -e "${YELLOW}Please free up at least $((required_mb - available_mb)) MB${NC}" >&2
    return 1
  fi
  
  echo -e "${GREEN}âœ“ Sufficient disk space available (${available_mb} MB)${NC}"
  return 0
}

# Enhanced download with better error messages and progress
download_file() {
  local url=$1
  local output=$2
  local description=${3:-"file"}
  
  echo -e "${BLUE}Downloading ${description}...${NC}"
  
  if ! wget --no-cookies --no-cache --show-progress -O "$output" "$url" 2>&1; then
    echo -e "${RED}Failed to download ${description}${NC}" >&2
    echo -e "${YELLOW}URL: $url${NC}" >&2
    echo -e "${YELLOW}Please check your internet connection and try again${NC}" >&2
    return 1
  fi
  
  if [ ! -f "$output" ] || [ ! -s "$output" ]; then
    echo -e "${RED}Downloaded file is missing or empty${NC}" >&2
    return 1
  fi
  
  echo -e "${GREEN}âœ“ ${description} downloaded successfully${NC}"
  return 0
}

# Verify file checksum (if checksum provided)
verify_checksum() {
  local file=$1
  local expected_checksum=$2
  
  if [ -z "$expected_checksum" ] || [ "$expected_checksum" = "skip" ]; then
    return 0
  fi
  
  echo -e "${BLUE}Verifying file integrity...${NC}"
  
  local actual_checksum=$(sha256sum "$file" | awk '{print $1}')
  
  if [ "$actual_checksum" != "$expected_checksum" ]; then
    echo -e "${RED}Checksum verification failed!${NC}" >&2
    echo -e "${YELLOW}Expected: $expected_checksum${NC}" >&2
    echo -e "${YELLOW}Got: $actual_checksum${NC}" >&2
    echo -e "${RED}File may be corrupted or tampered with${NC}" >&2
    return 1
  fi
  
  echo -e "${GREEN}âœ“ Checksum verified${NC}"
  return 0
}

# Set secure file permissions
set_secure_permissions() {
  local file=$1
  local perms=${2:-600}
  
  if [ -f "$file" ]; then
    chmod "$perms" "$file"
    echo -e "${GREEN}âœ“ Secure permissions set on $(basename "$file")${NC}"
  fi
}

# Show progress indicator for long operations
show_progress() {
  local message=$1
  local pid=$2
  
  local spin='-\|/'
  local i=0
  
  while kill -0 $pid 2>/dev/null; do
    i=$(( (i+1) %4 ))
    printf "\r${CYAN}%s ${spin:$i:1}${NC}" "$message"
    sleep 0.1
  done
  
  printf "\r%s\n" "$message"
}

# Check and display missing dependencies with helpful messages
check_dependency() {
  local cmd=$1
  local package=${2:-$1}
  local description=$3
  
  if ! command -v "$cmd" >/dev/null 2>&1; then
    echo -e "${YELLOW}âš  Missing dependency: ${BOLD}$package${NC}"
    if [ -n "$description" ]; then
      echo -e "${BLUE}  Purpose: $description${NC}"
    fi
    echo -e "${BLUE}  Install: ${BOLD}apt-get install $package${NC}"
    return 1
  fi
  
  return 0
}

# Format bytes to human readable
format_bytes() {
  local bytes=$1
  
  if [ $bytes -lt 1024 ]; then
    echo "${bytes}B"
  elif [ $bytes -lt 1048576 ]; then
    echo "$((bytes / 1024))KB"
  elif [ $bytes -lt 1073741824 ]; then
    echo "$((bytes / 1048576))MB"
  else
    echo "$((bytes / 1073741824))GB"
  fi
}

# Check if server is running
is_server_running() {
  if tmux has-session -t hytale-server 2>/dev/null; then
    return 0
  fi
  return 1
}

# Check if auto-start is enabled
is_autostart_enabled() {
  if crontab -l 2>/dev/null | grep -q "@reboot.*$(basename $0) start"; then
    return 0
  fi
  return 1
}

# Create backup with unified logic
create_backup_archive() {
  local backup_name=$1
  local backup_path="$BACKUP_DIR/$backup_name"
  
  # Ensure backup directory exists
  mkdir -p "$BACKUP_DIR"
  
  # Build list of files to backup
  local backup_items=()
  
  if [ -d "$BASE_DIR/universe" ]; then
    backup_items+=("universe")
    echo -e "${BLUE}  â†’ universe/${NC}"
  fi
  
  if [ -d "$BASE_DIR/mods" ]; then
    backup_items+=("mods")
    echo -e "${BLUE}  â†’ mods/${NC}"
  fi
  
  for file in bans.json config.json permissions.json whitelist.json; do
    if [ -f "$BASE_DIR/$file" ]; then
      backup_items+=("$file")
      echo -e "${BLUE}  â†’ $file${NC}"
    fi
  done
  
  if [ ${#backup_items[@]} -eq 0 ]; then
    echo -e "${YELLOW}âš  No backup items found${NC}"
    return 1
  fi
  
  # Create compressed backup
  if tar -czf "$backup_path" -C "$BASE_DIR" "${backup_items[@]}" 2>/dev/null; then
    # Fix ownership to match the base directory owner
    chown --reference="$BASE_DIR" "$backup_path" 2>/dev/null || true
    local backup_size=$(du -h "$backup_path" | cut -f1)
    echo -e "${GREEN}âœ“ Backup created: $backup_name (${backup_size})${NC}"
    echo "$backup_path"
    return 0
  else
    echo -e "${RED}Failed to create backup${NC}" >&2
    return 1
  fi
}

# ================================================================

uninstall_server() {
  echo ""
  echo -e "${BOLD}${YELLOW}=== Uninstalling Hytale Server ===${NC}"
  echo ""
  
  # Use default port if CUSTOM_PORT is not set
  UNINSTALL_PORT=${CUSTOM_PORT:-$PORT}
  
  # Stop server if running
  if is_server_running; then
    echo -e "${BLUE}Stopping Hytale server...${NC}"
    tmux kill-session -t hytale-server 2>/dev/null || true
    echo -e "${GREEN}âœ“ Server stopped${NC}"
  fi
  
  # Remove PID file
  if [ -f "$PID_FILE" ]; then
    rm -f "$PID_FILE"
  fi
  
  # Remove server files
  if [ -d "$BASE_DIR" ]; then
    echo -e "${BLUE}Removing server files from $BASE_DIR...${NC}"
    rm -rf "$BASE_DIR"
  fi
  
  # Remove tools directory
  if [ -d "$TOOLS_DIR" ]; then
    echo -e "${BLUE}Removing tools directory...${NC}"
    rm -rf "$TOOLS_DIR"
  fi
  
  # Remove temp directory
  if [ -d "$TEMP_DIR" ]; then
    echo -e "${BLUE}Removing temp directory...${NC}"
    rm -rf "$TEMP_DIR"
  fi
  
  # Remove firewall rule
  if command -v ufw >/dev/null 2>&1; then
    echo -e "${BLUE}Removing firewall rule...${NC}"
    ufw delete allow ${UNINSTALL_PORT}/udp 2>/dev/null || true
  fi
  
  # Remove cron jobs
  echo -e "${BLUE}Removing scheduled tasks...${NC}"
  crontab -l 2>/dev/null | grep -v "restart hytale\|restart >" | grep -v "backup >" | grep -v "@reboot.*start" | crontab - 2>/dev/null || true
  echo -e "${GREEN}âœ“ Scheduled tasks removed${NC}"
  
  echo ""
  echo -e "${GREEN}==========================================${NC}"
  echo -e "${BOLD}${GREEN}Uninstall complete!${NC}"
  echo -e "${GREEN}==========================================${NC}"
}
backup_server() {
  echo ""
  echo -e "${BOLD}${YELLOW}=== Creating Hytale Server Backup ===${NC}"
  echo ""
  
  # Create base directory if it doesn't exist
  if [ ! -d "$BASE_DIR" ]; then
    echo -e "${YELLOW}WARNING: Server directory not found. Creating $BASE_DIR${NC}"
    mkdir -p "$BASE_DIR"
  fi
  
  # Check disk space before backup
  if ! check_disk_space 1024 "$SCRIPT_DIR"; then
    echo -e "${RED}Cannot create backup due to insufficient disk space${NC}" >&2
    exit 1
  fi
  
  # Generate backup filename with timestamp
  BACKUP_NAME="hytale-backup-$(date +%Y%m%d-%H%M%S).tar.gz"
  
  echo -e "${CYAN}[1/3]${NC} Creating backup archive..."
  echo -e "${BLUE}Backing up world data and configuration files...${NC}"
  
  # Use unified backup function
  if ! BACKUP_PATH=$(create_backup_archive "$BACKUP_NAME"); then
    echo -e "${RED}Failed to create backup${NC}" >&2
    exit 1
  fi
  
  echo -e "${CYAN}[2/3]${NC} Managing backup retention..."
  # Count backups
  BACKUP_COUNT=$(ls -1 "$BACKUP_DIR"/hytale-backup-*.tar.gz 2>/dev/null | wc -l)
  echo -e "${BLUE}Total backups: ${BACKUP_COUNT}${NC}"
  
  # Remove old backups if exceeding retention
  if [ "$BACKUP_COUNT" -gt "$BACKUP_RETENTION" ]; then
    REMOVE_COUNT=$((BACKUP_COUNT - BACKUP_RETENTION))
    echo -e "${YELLOW}Removing ${REMOVE_COUNT} old backup(s)...${NC}"
    ls -1t "$BACKUP_DIR"/hytale-backup-*.tar.gz | tail -n "$REMOVE_COUNT" | xargs rm -f
    echo -e "${GREEN}âœ“ Old backups removed (keeping last ${BACKUP_RETENTION})${NC}"
  else
    echo -e "${GREEN}âœ“ Retention policy satisfied (keeping last ${BACKUP_RETENTION})${NC}"
  fi
  
  echo -e "${CYAN}[3/3]${NC} Backup complete!"
  echo ""
  echo -e "${GREEN}===========================================${NC}"
  echo -e "${BOLD}${GREEN}Backup saved to:${NC}"
  echo -e "${BLUE}$BACKUP_PATH${NC}"
  echo -e "${GREEN}===========================================${NC}"
}

restore_server() {
  echo ""
  echo -e "${BOLD}${YELLOW}=== Restoring Hytale Server from Backup ===${NC}"
  echo ""
  
  # Check if backup directory exists
  if [ ! -d "$BACKUP_DIR" ] || [ -z "$(ls -A "$BACKUP_DIR"/hytale-backup-*.tar.gz 2>/dev/null)" ]; then
    echo -e "${RED}ERROR: No backups found in $BACKUP_DIR${NC}"
    echo -e "${YELLOW}Create a backup first using: ./Hytale-Server backup${NC}"
    exit 1
  fi
  
  # List available backups
  echo -e "${CYAN}Available backups:${NC}"
  echo ""
  
  BACKUPS=($(ls -1t "$BACKUP_DIR"/hytale-backup-*.tar.gz 2>/dev/null))
  
  for i in "${!BACKUPS[@]}"; do
    BACKUP_FILE="${BACKUPS[$i]}"
    BACKUP_NAME=$(basename "$BACKUP_FILE")
    BACKUP_SIZE=$(du -h "$BACKUP_FILE" | cut -f1)
    BACKUP_DATE=$(echo "$BACKUP_NAME" | grep -oP '\d{8}-\d{6}' | sed 's/\([0-9]\{4\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)-\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)/\1-\2-\3 \4:\5:\6/')
    echo -e "  ${BOLD}[$((i+1))]${NC} $BACKUP_DATE (${BACKUP_SIZE})"
  done
  
  echo ""
  read -p "Select backup to restore (1-${#BACKUPS[@]}) or 'q' to quit: " SELECTION
  
  if [ "$SELECTION" = "q" ] || [ "$SELECTION" = "Q" ]; then
    echo -e "${YELLOW}Restore cancelled.${NC}"
    exit 0
  fi
  
  # Validate selection
  if ! [[ "$SELECTION" =~ ^[0-9]+$ ]] || [ "$SELECTION" -lt 1 ] || [ "$SELECTION" -gt "${#BACKUPS[@]}" ]; then
    echo -e "${RED}Invalid selection.${NC}"
    exit 1
  fi
  
  SELECTED_BACKUP="${BACKUPS[$((SELECTION-1))]}"
  SELECTED_NAME=$(basename "$SELECTED_BACKUP")
  
  echo ""
  echo -e "${YELLOW}WARNING: This will replace all current server files!${NC}"
  read -p "Are you sure you want to restore from $SELECTED_NAME? (yes/no): " CONFIRM
  
  if [ "$CONFIRM" != "yes" ]; then
    echo -e "${YELLOW}Restore cancelled.${NC}"
    exit 0
  fi
  
  # Stop server if running
  SERVER_WAS_RUNNING=false
  if is_server_running; then
    echo -e "${CYAN}[1/4]${NC} Stopping Hytale server..."
    tmux kill-session -t hytale-server 2>/dev/null || true
    
    # Wait for server to fully stop
    for i in {1..10}; do
      if ! is_server_running; then
        break
      fi
      sleep 1
    done
    
    echo -e "${GREEN}âœ“ Server stopped${NC}"
    SERVER_WAS_RUNNING=true
  else
    echo -e "${CYAN}[1/4]${NC} Server not running, proceeding..."
  fi
  
  # Backup current state (just in case)
  echo -e "${CYAN}[2/4]${NC} Creating safety backup of current state..."
  SAFETY_BACKUP_NAME="pre-restore-$(date +%Y%m%d-%H%M%S).tar.gz"
  
  # Use unified backup function
  if SAFETY_BACKUP=$(create_backup_archive "$SAFETY_BACKUP_NAME" 2>/dev/null); then
    echo -e "${GREEN}âœ“ Safety backup created${NC}"
  else
    echo -e "${YELLOW}âš  No existing data to backup${NC}"
    SAFETY_BACKUP=""
  fi
  
  # Remove current world data and config files
  echo -e "${CYAN}[3/4]${NC} Removing current world data and config files..."
  [ -d "$BASE_DIR/universe" ] && rm -rf "$BASE_DIR/universe"
  for file in bans.json config.json permissions.json whitelist.json; do
    [ -f "$BASE_DIR/$file" ] && rm -f "$BASE_DIR/$file"
  done
  echo -e "${GREEN}âœ“ Current data removed${NC}"
  
  # Extract backup
  echo -e "${CYAN}[4/4]${NC} Restoring from backup..."
  if tar -xzf "$SELECTED_BACKUP" -C "$BASE_DIR" 2>/dev/null; then
    echo -e "${GREEN}âœ“ Backup restored successfully${NC}"
  else
    echo -e "${RED}Failed to restore backup!${NC}" >&2
    
    # Rollback to safety backup if available
    if [ -n "$SAFETY_BACKUP" ] && [ -f "$SAFETY_BACKUP" ]; then
      echo -e "${YELLOW}Rolling back to safety backup...${NC}"
      if tar -xzf "$SAFETY_BACKUP" -C "$BASE_DIR" 2>/dev/null; then
        echo -e "${GREEN}âœ“ Rollback successful${NC}"
      else
        echo -e "${RED}Rollback failed! Server may be in an inconsistent state${NC}" >&2
      fi
    fi
    exit 1
  fi
  
  # Ask to restart server (or auto-restart if it was running)
  echo ""
  if [ "$SERVER_WAS_RUNNING" = true ]; then
    read -p "Server was running. Restart now? (yes/no) [yes]: " START_NOW
    START_NOW=${START_NOW:-yes}
  else
    read -p "Start the server now? (yes/no): " START_NOW
  fi
  
  if [ "$START_NOW" = "yes" ]; then
    "$BASE_DIR/start.sh" &
    sleep 3
    if is_server_running; then
      echo -e "${GREEN}Server started.${NC}"
    else
      echo -e "${YELLOW}Server may be starting, check with: $0 status${NC}"
    fi
  fi
  
  echo ""
  echo -e "${GREEN}===========================================${NC}"
  echo -e "${BOLD}${GREEN}Restore complete!${NC}"
  echo -e "${BLUE}Restored from: $SELECTED_NAME${NC}"
  echo -e "${GREEN}===========================================${NC}"
}

toggle_autobackup() {
  echo ""
  echo -e "${BOLD}${YELLOW}=== Auto-Backup Configuration ===${NC}"
  echo ""
  
  # Check if auto-backup cron exists
  if crontab -l 2>/dev/null | grep -q "backup > /dev/null"; then
    echo -e "${YELLOW}Auto-backup is currently: ${BOLD}ENABLED${NC}"
    echo ""
    read -p "Do you want to disable auto-backup? (yes/no): " DISABLE
    
    if [ "$DISABLE" = "yes" ]; then
      crontab -l 2>/dev/null | grep -v "backup > /dev/null" | crontab - || true
      echo -e "${GREEN}âœ“ Auto-backup disabled${NC}"
    else
      echo -e "${YELLOW}Auto-backup remains enabled${NC}"
    fi
  else
    echo -e "${YELLOW}Auto-backup is currently: ${BOLD}DISABLED${NC}"
    echo ""
    echo -e "${CYAN}Configure automatic daily backups:${NC}"
    read -p "Enable auto-backup? (yes/no): " ENABLE
    
    if [ "$ENABLE" = "yes" ]; then
      ( crontab -l 2>/dev/null | grep -v "backup > /dev/null" ; echo "$BACKUP_CRON" ) | crontab - || true
      
      echo -e "${GREEN}âœ“ Auto-backup enabled${NC}"
      echo -e "${BLUE}Backups will run daily at 2:00 AM${NC}"
      echo -e "${BLUE}Retention: ${BACKUP_RETENTION} backups${NC}"
    else
      echo -e "${YELLOW}Auto-backup remains disabled${NC}"
    fi
  fi
  
  echo ""
  echo -e "${GREEN}===========================================${NC}"
}

toggle_autorestart() {
  echo ""
  echo -e "${BOLD}${YELLOW}=== Auto-Restart Configuration ===${NC}"
  echo ""
  
  # Check if auto-restart cron exists
  if crontab -l 2>/dev/null | grep -q "restart hytale\|restart >"; then
    echo -e "${YELLOW}Auto-restart is currently: ${BOLD}ENABLED${NC}"
    echo ""
    read -p "Do you want to disable auto-restart? (yes/no): " DISABLE
    
    if [ "$DISABLE" = "yes" ]; then
      crontab -l 2>/dev/null | grep -v "restart hytale\|restart >" | crontab - || true
      echo -e "${GREEN}âœ“ Auto-restart disabled${NC}"
    else
      echo -e "${YELLOW}Auto-restart remains enabled${NC}"
    fi
  else
    echo -e "${YELLOW}Auto-restart is currently: ${BOLD}DISABLED${NC}"
    echo ""
    echo -e "${CYAN}Configure automatic server restart every 3 days:${NC}"
    read -p "Enable auto-restart? (yes/no): " ENABLE
    
    if [ "$ENABLE" = "yes" ]; then
      ( crontab -l 2>/dev/null | grep -v "restart hytale\|restart >" ; echo "$RESTART_CRON" ) | crontab - || true
      
      echo -e "${GREEN}âœ“ Auto-restart enabled${NC}"
      echo -e "${BLUE}Server will restart every 3 days at midnight${NC}"
    else
      echo -e "${YELLOW}Auto-restart remains disabled${NC}"
    fi
  fi
  
  echo ""
  echo -e "${GREEN}===========================================${NC}"
}
update_server() {
  echo ""
  echo -e "${BOLD}${YELLOW}=== Updating Hytale Server ===${NC}"
  echo ""
  
  # Check if server is installed
  if [ ! -f "$BASE_DIR/start.sh" ]; then
    echo -e "${RED}ERROR: Hytale server is not installed.${NC}"
    echo -e "${YELLOW}Please install it first using: $0 install${NC}"
    exit 1
  fi
  
  # Check disk space
  if ! check_disk_space "$MIN_DISK_SPACE_MB" "$SCRIPT_DIR"; then
    echo -e "${RED}Cannot proceed with update${NC}" >&2
    exit 1
  fi
  
  # Create rollback backup
  echo -e "${CYAN}[1/6]${NC} Creating pre-update backup for rollback..."
  ROLLBACK_BACKUP_NAME="pre-update-$(date +%Y%m%d-%H%M%S).tar.gz"
  
  if ROLLBACK_BACKUP=$(create_backup_archive "$ROLLBACK_BACKUP_NAME" 2>/dev/null); then
    echo -e "${GREEN}âœ“ Rollback backup created${NC}"
  else
    echo -e "${YELLOW}âš  Warning: Could not create rollback backup${NC}"
    read -p "Continue without rollback capability? (yes/no): " CONTINUE
    if [ "$CONTINUE" != "yes" ]; then
      echo -e "${YELLOW}Update cancelled${NC}"
      exit 0
    fi
    ROLLBACK_BACKUP=""
  fi
  
  echo -e "${CYAN}[2/6]${NC} Stopping Hytale server..."
  if is_server_running; then
    tmux kill-session -t hytale-server 2>/dev/null || true
    sleep 2
  fi
  
  # Create temp directory
  mkdir -p "$TEMP_DIR"
  mkdir -p "$TOOLS_DIR"
  
  echo -e "${CYAN}[3/6]${NC} Downloading Hytale Downloader..."
  cd "$TEMP_DIR" || { echo -e "${RED}Failed to change to $TEMP_DIR.${NC}" >&2; exit 1; }
  
  if [ ! -f "$TOOLS_DIR/hytale-downloader-linux-amd64" ]; then
    if ! download_file "$DOWNLOADER_URL" "hytale-downloader.zip" "Hytale Downloader"; then
      exit 1
    fi
    
    if unzip -q hytale-downloader.zip; then
      chmod +x hytale-downloader-linux-amd64
      mv hytale-downloader-linux-amd64 "$TOOLS_DIR/"
      rm -f hytale-downloader-windows-amd64.exe hytale-downloader.zip QUICKSTART.md
    else
      echo -e "${RED}Failed to extract Hytale Downloader${NC}" >&2
      exit 1
    fi
  fi
  
  # Copy credentials if they exist and set secure permissions
  if [ -f "$TOOLS_DIR/.hytale-downloader-credentials.json" ]; then
    cp "$TOOLS_DIR/.hytale-downloader-credentials.json" .
    set_secure_permissions ".hytale-downloader-credentials.json" 600
  fi
  
  echo -e "${CYAN}[4/6]${NC} Downloading latest server files..."
  if "$TOOLS_DIR/hytale-downloader-linux-amd64"; then
    echo -e "${GREEN}Server files downloaded.${NC}"
  else
    echo -e "${RED}Failed to download server files.${NC}" >&2
    echo -e "${YELLOW}Check your internet connection and Hytale account credentials${NC}" >&2
    
    # Attempt rollback
    if [ -n "$ROLLBACK_BACKUP" ] && [ -f "$ROLLBACK_BACKUP" ]; then
      echo -e "${YELLOW}Rolling back to pre-update state...${NC}"
      tar -xzf "$ROLLBACK_BACKUP" -C "$BASE_DIR" 2>/dev/null
    fi
    
    exit 1
  fi
  
  DOWNLOADED_ZIP=$(ls -t *.zip 2>/dev/null | head -1)
  
  if [ -z "$DOWNLOADED_ZIP" ]; then
    echo -e "${RED}No zip file found after download.${NC}" >&2
    
    # Attempt rollback
    if [ -n "$ROLLBACK_BACKUP" ] && [ -f "$ROLLBACK_BACKUP" ]; then
      echo -e "${YELLOW}Rolling back to pre-update state...${NC}"
      tar -xzf "$ROLLBACK_BACKUP" -C "$BASE_DIR" 2>/dev/null
    fi
    
    exit 1
  fi
  
  echo -e "${CYAN}[5/6]${NC} Extracting and updating server files..."
  echo -e "${BLUE}Extracting files:${NC}"
  if unzip -o "$DOWNLOADED_ZIP" | grep -E "(inflating|extracting):" | sed "s/^/  ${CYAN}â†’${NC} /"; then
    echo -e "${GREEN}âœ“ Extraction complete.${NC}"
  else
    echo -e "${RED}Failed to extract server files.${NC}" >&2
    
    # Attempt rollback
    if [ -n "$ROLLBACK_BACKUP" ] && [ -f "$ROLLBACK_BACKUP" ]; then
      echo -e "${YELLOW}Rolling back to pre-update state...${NC}"
      tar -xzf "$ROLLBACK_BACKUP" -C "$BASE_DIR" 2>/dev/null
    fi
    
    exit 1
  fi
  
  # Update server files (keep existing config and world data)
  if [ -d "Server" ]; then
    # Remove old server files but keep world data, configs, and start script
    find "$BASE_DIR" -mindepth 1 -maxdepth 1 ! -name 'universe'  ! -name 'mods' ! -name '*.json' ! -name 'backups' ! -name 'logs' ! -name '*.sh' ! -name '*.enc' -exec rm -rf {} + 2>/dev/null || true
    
    if ! cp -r Server/* "$BASE_DIR/" 2>/dev/null; then
      echo -e "${RED}Failed to copy server files.${NC}" >&2
      
      # Attempt rollback
      if [ -n "$ROLLBACK_BACKUP" ] && [ -f "$ROLLBACK_BACKUP" ]; then
        echo -e "${YELLOW}Rolling back to pre-update state...${NC}"
        tar -xzf "$ROLLBACK_BACKUP" -C "$BASE_DIR" 2>/dev/null
      fi
      
      exit 1
    fi
  fi
  
  if [ -f "Assets.zip" ]; then
    cp "Assets.zip" "$BASE_DIR/" || { echo "Failed to copy Assets.zip." >&2; exit 1; }
  fi
  
  # Save credentials back to tools directory with secure permissions
  if [ -f ".hytale-downloader-credentials.json" ]; then
    cp ".hytale-downloader-credentials.json" "$TOOLS_DIR/"
    set_secure_permissions "$TOOLS_DIR/.hytale-downloader-credentials.json" 600
  fi
  
  # Clean up temp directory
  cd "$BASE_DIR" || exit 1
  rm -rf "$TEMP_DIR"
  mkdir -p "$TEMP_DIR"
  
  echo -e "${CYAN}[6/6]${NC} Starting Hytale server..."
  "$BASE_DIR/start.sh" &
  sleep 3
  
  echo ""
  echo -e "${GREEN}==========================================${NC}"
  echo -e "${BOLD}${GREEN}Update complete!${NC}"
  echo -e "${GREEN}==========================================${NC}"
}

install_server() {
  echo ""
  echo -e "${BOLD}${CYAN}=== Installing Hytale Dedicated Server ===${NC}"
  echo ""
  
  # Check if already installed
  if is_server_running; then
    echo -e "${YELLOW}WARNING: Hytale server is already running!${NC}"
    echo -e "${YELLOW}Please stop it first using: $0 stop${NC}"
    exit 1
  fi

  # Port configuration
  echo -e "${CYAN}Port Configuration${NC}"
  while true; do
    read -p "Enter server port (default: 5520): " CUSTOM_PORT
    
    if [ -z "$CUSTOM_PORT" ]; then
      CUSTOM_PORT=$PORT
      echo -e "${BLUE}Using default port: ${CUSTOM_PORT}${NC}"
      break
    elif validate_port "$CUSTOM_PORT"; then
      echo -e "${GREEN}Using custom port: ${CUSTOM_PORT}${NC}"
      break
    else
      echo -e "${RED}Please enter a valid port number (1024-65535)${NC}"
    fi
  done
  echo ""

  # Auto-backup configuration
  echo -e "${CYAN}Auto-Backup Configuration${NC}"
  echo -e "${BLUE}Would you like to enable automatic daily backups?${NC}"
  read -p "Enable auto-backup? (yes/no): " ENABLE_AUTOBACKUP
  echo ""

  # Auto-restart configuration
  echo -e "${CYAN}Auto-Restart Configuration${NC}"
  echo -e "${BLUE}Would you like to enable automatic server restart every 3 days?${NC}"
  echo -e "${YELLOW}(Helps keep server running smoothly and apply updates)${NC}"
  read -p "Enable auto-restart? (yes/no): " ENABLE_AUTORESTART
  echo ""

  # Memory configuration
  echo -e "${CYAN}JVM Memory Configuration${NC}"
  echo -e "${BLUE}Configure Java heap memory allocation for the server:${NC}"
  echo -e "${YELLOW}Recommended settings based on available RAM:${NC}"
  echo -e "${YELLOW}  - 8GB RAM:  Min=2, Max=4${NC}"
  echo -e "${YELLOW}  - 16GB RAM: Min=4, Max=8${NC}"
  echo -e "${YELLOW}  - 32GB RAM: Min=8, Max=16${NC}"
  echo ""
  
  while true; do
    read -p "Enter minimum heap size in GB (default: 4): " MIN_HEAP
    read -p "Enter maximum heap size in GB (default: 8): " MAX_HEAP
    
    # Set defaults if empty
    MIN_HEAP=${MIN_HEAP:-4}
    MAX_HEAP=${MAX_HEAP:-8}
    
    # Validate memory settings
    if ! [[ "$MIN_HEAP" =~ ^[0-9]+$ ]] || ! [[ "$MAX_HEAP" =~ ^[0-9]+$ ]]; then
      echo -e "${RED}Memory values must be numbers${NC}"
      continue
    fi
    
    if [ "$MIN_HEAP" -gt "$MAX_HEAP" ]; then
      echo -e "${RED}Minimum heap cannot be larger than maximum heap${NC}"
      continue
    fi
    
    if [ "$MIN_HEAP" -lt 1 ] || [ "$MAX_HEAP" -lt 1 ]; then
      echo -e "${RED}Memory values must be at least 1GB${NC}"
      continue
    fi
    
    break
  done

  echo -e "${GREEN}Memory settings: -Xms${MIN_HEAP}G -Xmx${MAX_HEAP}G${NC}"
  echo ""

echo -e "${CYAN}[1/7]${NC} Checking dependencies..."

MISSING_DEPS=()

# Check for required dependencies
if ! check_dependency "unzip" "unzip" "Extract downloaded archives"; then
  MISSING_DEPS+=("unzip")
fi

if ! check_dependency "tmux" "tmux" "Manage server console sessions"; then
  MISSING_DEPS+=("tmux")
fi

if ! check_dependency "crontab" "cron" "Schedule automated tasks (backups, restarts)"; then
  MISSING_DEPS+=("cron")
fi

# Install missing dependencies if any
if [ ${#MISSING_DEPS[@]} -gt 0 ]; then
  echo ""
  echo -e "${YELLOW}Installing missing dependencies...${NC}"
  apt-get update -qq
  
  for dep in "${MISSING_DEPS[@]}"; do
    echo -e "${BLUE}Installing $dep...${NC}"
    apt-get install -y "$dep"
    echo -e "${GREEN}âœ“ $dep installed${NC}"
  done
  
  # Ensure cron service is enabled if installed
  if [[ " ${MISSING_DEPS[@]} " =~ " cron " ]]; then
    service cron start 2>/dev/null || /etc/init.d/cron start 2>/dev/null || true
  fi
else
  echo -e "${GREEN}âœ“ All dependencies are installed${NC}"
fi

echo -e "${BLUE}Checking Java installation...${NC}"
JAVA_VERSION_OUTPUT=$(java -version 2>&1 || true)
JAVA_VERSION=$(echo "$JAVA_VERSION_OUTPUT" | awk -F[\".] '/version/ {print $2}')

if [[ "$JAVA_VERSION_OUTPUT" == *"25."* || "$JAVA_VERSION" == "25" ]]; then
  echo -e "${GREEN}âœ“ Java 25 is already installed.${NC}"
else
  echo -e "${BLUE}Installing Java 25...${NC}"
  
  JAVA_DEB="jdk-25_linux-x64_bin.deb"
  JAVA_URL="https://download.oracle.com/java/25/latest/$JAVA_DEB"
  
  if download_file "$JAVA_URL" "$JAVA_DEB" "Java 25 JDK"; then
    if dpkg -i "$JAVA_DEB"; then
      echo -e "${GREEN}âœ“ Java 25 installed successfully.${NC}"
      rm "$JAVA_DEB"
    else
      echo -e "${RED}Failed to install Java.${NC}" >&2
      echo -e "${YELLOW}You may need to install it manually${NC}" >&2
      exit 1
    fi
  else
    echo -e "${RED}Cannot proceed without Java 25${NC}" >&2
    exit 1
  fi
fi

java --version || { echo -e "${RED}Java not found in PATH.${NC}" >&2; exit 1; }

# Check available disk space with helper function
if ! check_disk_space "$MIN_DISK_SPACE_MB" "$SCRIPT_DIR"; then
  exit 1
fi


# ---- 2. Create directories ----
echo -e "${CYAN}[2/7]${NC} Creating directories..."
mkdir -p "$BASE_DIR"
mkdir -p "$TOOLS_DIR"
mkdir -p "$TEMP_DIR"


# ---- 3. Install Hytale Downloader CLI ----
echo -e "${CYAN}[3/7]${NC} Downloading Hytale Downloader..."
cd "$TEMP_DIR" || { echo -e "${RED}Failed to change to $TEMP_DIR.${NC}" >&2; exit 1; }

if wget --no-cookies --no-cache --show-progress -O hytale-downloader.zip "$DOWNLOADER_URL"; then
  echo -e "${GREEN}Hytale Downloader downloaded.${NC}"
else
  echo -e "${RED}Failed to download Hytale Downloader.${NC}" >&2
  exit 1
fi
echo -e "${BLUE}Extracting Hytale Downloader...${NC}"
if unzip -q hytale-downloader.zip; then
  echo -e "${GREEN}âœ“ Extraction complete.${NC}"
else
  echo -e "${RED}Failed to extract Hytale Downloader.${NC}" >&2
  exit 1
fi

chmod +x hytale-downloader-linux-amd64
mv hytale-downloader-linux-amd64 "$TOOLS_DIR/"
rm -f hytale-downloader-windows-amd64.exe hytale-downloader.zip QUICKSTART.md


# ---- 4. Download server files ----
echo -e "${CYAN}[4/7]${NC} Downloading Hytale server files..."
cd "$TEMP_DIR" || { echo -e "${RED}Failed to change to $TEMP_DIR.${NC}" >&2; exit 1; }
if "$TOOLS_DIR/hytale-downloader-linux-amd64"; then
  echo -e "${GREEN}Server files downloaded.${NC}"
else
  echo -e "${RED}Failed to download server files.${NC}" >&2
  exit 1
fi

# Save credentials to tools directory with secure permissions
if [ -f ".hytale-downloader-credentials.json" ]; then
  cp ".hytale-downloader-credentials.json" "$TOOLS_DIR/"
  set_secure_permissions "$TOOLS_DIR/.hytale-downloader-credentials.json" 600
fi

# Expected structure: The downloader creates a zip file like "2026.01.15-c04fdfe10.zip"
# Find the most recently created zip file
DOWNLOADED_ZIP=$(ls -t *.zip 2>/dev/null | head -1)

if [ -z "$DOWNLOADED_ZIP" ]; then
  echo -e "${RED}No zip file found after download.${NC}" >&2
  exit 1
fi

echo -e "${BLUE}Extracting $DOWNLOADED_ZIP...${NC}"
echo -e "${BLUE}Extracting files:${NC}"
if unzip -o "$DOWNLOADED_ZIP" | grep -E "(inflating|extracting):" | sed "s/^/  ${CYAN}â†’${NC} /"; then
  echo -e "${GREEN}âœ“ Extraction complete.${NC}"
else
  echo -e "${RED}Failed to extract server files.${NC}" >&2
  exit 1
fi

# Expected structure after extraction: Server/ Assets.zip
echo -e "${BLUE}Copying server files to $BASE_DIR...${NC}"
if [ -d "Server" ]; then
  FILE_COUNT=$(find Server -type f | wc -l)
  echo -e "${BLUE}Copying ${FILE_COUNT} files...${NC}"
  cp -rv Server/* "$BASE_DIR/" 2>&1 | grep -v "^'" | sed "s/^/  ${CYAN}â†’${NC} /" || { echo -e "${RED}Failed to copy server files.${NC}" >&2; exit 1; }
  echo -e "${GREEN}âœ“ Server files copied.${NC}"
else
  echo -e "${RED}Server directory not found after extraction.${NC}" >&2
  exit 1
fi

if [ -f "Assets.zip" ]; then
  ASSETS_SIZE=$(du -h Assets.zip | cut -f1)
  echo -e "${BLUE}Copying Assets.zip (${ASSETS_SIZE})...${NC}"
  cp "Assets.zip" "$BASE_DIR/" || { echo -e "${RED}Failed to copy Assets.zip.${NC}" >&2; exit 1; }
  echo -e "${GREEN}âœ“ Assets.zip copied.${NC}"
else
  echo -e "${RED}Assets.zip not found after extraction.${NC}" >&2
  exit 1
fi

# Clean up temp directory
echo -e "${BLUE}Cleaning up temporary files...${NC}"
cd "$BASE_DIR" || exit 1
rm -rf "$TEMP_DIR"
mkdir -p "$TEMP_DIR"

echo -e "${CYAN}[5/7]${NC} Creating server start script..."

cat > "$BASE_DIR/start.sh" << EOF
#!/bin/bash
SCRIPT_DIR="\$(cd "\$(dirname "\$0")" && pwd)"
cd "\$SCRIPT_DIR"
LOGS_DIR="\$SCRIPT_DIR/logs"
SESSION_NAME="hytale-server"

# JVM Configuration
MIN_HEAP="${MIN_HEAP}"
MAX_HEAP="${MAX_HEAP}"

# Monitor logs and send auth command when needed
monitor_and_auth() {
  # Don't monitor if already authenticated
  if [ -f "\$SCRIPT_DIR/auth.enc" ]; then
    return 0
  fi
  
  while [ ! -d "\$LOGS_DIR" ]; do
    sleep 1
  done
  
  echo "[AUTH] Monitoring for authentication requests..."
  local SENT_AUTH=false
  
  while true; do
    LATEST_LOG=\$(ls -t "\$LOGS_DIR"/*.log 2>/dev/null | head -1)
    if [ -n "\$LATEST_LOG" ]; then
      # Check if server needs authentication
      if ! \$SENT_AUTH && tail -50 "\$LATEST_LOG" | grep -q "No server tokens configured"; then
        echo "[AUTH] Configuring authentication..."
        sleep 2
        tmux send-keys -t "\$SESSION_NAME" "/auth persistence Encrypted" C-m
        sleep 1
        tmux send-keys -t "\$SESSION_NAME" "/auth login device" C-m
        SENT_AUTH=true
      fi
    fi
    sleep 2
  done
}

# Start authentication monitor in background
monitor_and_auth &
MONITOR_PID=\$!

# Kill existing session if any
tmux kill-session -t "\$SESSION_NAME" 2>/dev/null || true

# Build Java command with optimizations
JAVA_CMD="java -Xms\${MIN_HEAP}G -Xmx\${MAX_HEAP}G"

# Add AOT cache if available (improves startup time)
if [ -f "\$SCRIPT_DIR/HytaleServer.aot" ]; then
  JAVA_AOT="-XX:AOTCache=HytaleServer.aot"
fi

JAVA_CMD="\$JAVA_CMD \$JAVA_AOT -jar HytaleServer.jar --assets Assets.zip"

# Start server in tmux session
tmux new-session -d -s "\$SESSION_NAME" "cd '\$SCRIPT_DIR' && \$JAVA_CMD"

echo "[INFO] Hytale server started"
echo "[INFO] Session: \$SESSION_NAME"
echo "[INFO] Memory: -Xms\${MIN_HEAP} -Xmx\${MAX_HEAP}"
echo "[INFO] Attach: tmux attach -t \$SESSION_NAME"
echo "[INFO] Detach: Ctrl+B then D"

# Monitor tmux session
while tmux has-session -t "\$SESSION_NAME" 2>/dev/null; do
  sleep 5
done

# Cleanup
kill \$MONITOR_PID 2>/dev/null || true
EOF


chmod +x "$BASE_DIR/start.sh"
echo -e "${GREEN}Start script created at $BASE_DIR/start.sh.${NC}"

echo -e "${CYAN}[6/7]${NC} Configuring firewall..."
if command -v ufw >/dev/null 2>&1; then
  echo -e "${BLUE}Configuring UFW firewall...${NC}"
  ufw allow ${CUSTOM_PORT}/udp
  echo -e "${GREEN}UFW rule added for UDP port ${CUSTOM_PORT}.${NC}"
else
  echo -e "${YELLOW}UFW not found. Please ensure UDP port ${CUSTOM_PORT} is open.${NC}"
fi


# ---- 8. Configure automatic tasks ----
echo -e "${CYAN}[7/7]${NC} Configuring automatic tasks..."

# Auto-start on boot
if [ "$ENABLE_AUTORESTART" = "yes" ]; then
  echo -e "${BLUE}Setting up auto-start on boot...${NC}"
  ( crontab -l 2>/dev/null | grep -v "@reboot.*start" ; echo "$AUTOSTART_CRON" ) | crontab - || true
  echo -e "${GREEN}âœ“ Auto-start enabled${NC}"
  echo -e "${BLUE}  â†’ Server will start automatically after system reboot${NC}"
fi

# Auto-restart cron
if [ "$ENABLE_AUTORESTART" = "yes" ]; then
  echo -e "${BLUE}Setting up periodic auto-restart...${NC}"
  ( crontab -l 2>/dev/null | grep -v "restart hytale\|restart >" ; echo "$RESTART_CRON" ) | crontab - || true
  echo -e "${GREEN}âœ“ Periodic auto-restart enabled${NC}"
  echo -e "${BLUE}  â†’ Server will restart every 3 days at midnight${NC}"
fi

if [ "$ENABLE_AUTOBACKUP" = "yes" ]; then
  echo -e "${BLUE}Setting up auto-backup...${NC}"
  ( crontab -l 2>/dev/null | grep -v "backup > /dev/null" ; echo "$BACKUP_CRON" ) | crontab - || true
  
  echo -e "${GREEN}âœ“ Auto-backup enabled${NC}"
  echo -e "${BLUE}  â†’ Backups will run daily at 2:00 AM${NC}"
  echo -e "${BLUE}  â†’ Retention: ${BACKUP_RETENTION} backups${NC}"
fi

if [ "$ENABLE_AUTORESTART" != "yes" ] && [ "$ENABLE_AUTOBACKUP" != "yes" ]; then
  echo -e "${YELLOW}No automatic tasks configured.${NC}"
  echo -e "${YELLOW}You can enable them later with: $0 autobackup or $0 autorestart${NC}"
fi


# ---- DONE ----
echo ""
echo -e "${CYAN}Finalizing installation...${NC}"

# Set secure permissions on sensitive files
echo -e "${BLUE}Setting secure file permissions...${NC}"
if [ -f "$TOOLS_DIR/.hytale-downloader-credentials.json" ]; then
  set_secure_permissions "$TOOLS_DIR/.hytale-downloader-credentials.json" 600
fi

# Get server IPv4 address
SERVER_IP=$(hostname -I | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -n1)

echo ""
echo -e "${GREEN}==========================================${NC}"
echo -e "${BOLD}${GREEN}INSTALLATION COMPLETE!${NC}"
echo -e "${GREEN}==========================================${NC}"
echo ""
echo -e "${YELLOW}âš   Server is NOT started automatically.${NC}"
echo -e "${YELLOW}   Start it with: ${BOLD}$0 start${NC}"
echo ""
echo -e "${CYAN}${BOLD}NEXT STEPS:${NC}"
echo ""
echo -e "${BOLD}1)${NC} Start the server:"
echo -e "   ${CYAN}$0 start${NC}"
echo ""
echo -e "${BOLD}2)${NC} Attach to server console:"
echo -e "   ${CYAN}$0 console${NC}"
echo -e "   ${YELLOW}(Detach: Ctrl+B then D)${NC}"
echo ""
echo -e "${BOLD}3)${NC} View server status:"
echo -e "   ${CYAN}$0 status${NC}"
echo ""
echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${BOLD}${CYAN}SERVER DETAILS${NC}"
echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
echo -e "${BLUE}IP Address:      ${BOLD}$SERVER_IP:$CUSTOM_PORT${NC}"
echo -e "${BLUE}Directory:       $BASE_DIR${NC}"
echo -e "${BLUE}Tools:           $TOOLS_DIR${NC}"
echo -e "${BLUE}Tmux Session:    hytale-server${NC}"
echo -e "${GREEN}==========================================${NC}"
}

# Show server status
show_status() {
  echo ""
  echo -e "${BOLD}${CYAN}=== Hytale Server Status ===${NC}"
  echo ""
  
  # Check if installed
  if [ ! -f "$BASE_DIR/start.sh" ]; then
    echo -e "${RED}Server: NOT INSTALLED${NC}"
    echo ""
    echo -e "${YELLOW}Run '$0 install' to install the server.${NC}"
    return
  fi
  
  # Server status
  if is_server_running; then
    echo -e "${GREEN}Server Status: RUNNING âœ“${NC}"
  else
    echo -e "${RED}Server Status: STOPPED âœ—${NC}"
  fi
  
  # Auto-start on boot
  if is_autostart_enabled; then
    echo -e "${GREEN}Auto-start: ENABLED âœ“${NC}"
  else
    echo -e "${YELLOW}Auto-start: DISABLED âœ—${NC}"
  fi
  
  echo ""
  echo -e "${BOLD}${CYAN}Scheduled Tasks:${NC}"
  
  # Auto-backup status
  if crontab -l 2>/dev/null | grep -q "backup > /dev/null"; then
    echo -e "${GREEN}Auto-backup: ENABLED âœ“${NC}"
    
    # Extract hour and minute from BACKUP_CRON
    BACKUP_HOUR=$(echo "$BACKUP_CRON" | awk '{print $2}')
    BACKUP_MIN=$(echo "$BACKUP_CRON" | awk '{print $1}')
    
    # Format time display
    if [ "$BACKUP_HOUR" -eq 0 ] && [ "$BACKUP_MIN" -eq 0 ]; then
      TIME_DISPLAY="midnight"
    elif [ "$BACKUP_HOUR" -lt 12 ]; then
      TIME_DISPLAY="${BACKUP_HOUR}:$(printf '%02d' $BACKUP_MIN) AM"
    elif [ "$BACKUP_HOUR" -eq 12 ]; then
      TIME_DISPLAY="${BACKUP_HOUR}:$(printf '%02d' $BACKUP_MIN) PM"
    else
      TIME_DISPLAY="$((BACKUP_HOUR - 12)):$(printf '%02d' $BACKUP_MIN) PM"
    fi
    
    echo -e "${BLUE}  â†’ Daily at ${TIME_DISPLAY}${NC}"
    
    # Calculate time until next backup
    CURRENT_HOUR=$(date +%H)
    CURRENT_MIN=$(date +%M)
    CURRENT_TIME_MIN=$((CURRENT_HOUR * 60 + CURRENT_MIN))
    BACKUP_TIME_MIN=$((BACKUP_HOUR * 60 + BACKUP_MIN))
    
    if [ $CURRENT_TIME_MIN -lt $BACKUP_TIME_MIN ]; then
      # Next run is today
      MINUTES_UNTIL=$((BACKUP_TIME_MIN - CURRENT_TIME_MIN))
    else
      # Next run is tomorrow
      MINUTES_UNTIL=$((1440 - CURRENT_TIME_MIN + BACKUP_TIME_MIN))
    fi
    
    HOURS_UNTIL=$((MINUTES_UNTIL / 60))
    MINS_UNTIL=$((MINUTES_UNTIL % 60))
    
    if [ $HOURS_UNTIL -gt 0 ]; then
      echo -e "${BLUE}  â†’ Next run in: ${HOURS_UNTIL}h ${MINS_UNTIL}m${NC}"
    else
      echo -e "${BLUE}  â†’ Next run in: ${MINS_UNTIL}m${NC}"
    fi
  else
    echo -e "${YELLOW}Auto-backup: DISABLED âœ—${NC}"
  fi
  
  # Auto-restart status
  if crontab -l 2>/dev/null | grep -q "restart hytale\|restart >"; then
    echo -e "${GREEN}Auto-restart: ENABLED âœ“${NC}"
    
    # Extract hour and minute from RESTART_CRON
    RESTART_HOUR=$(echo "$RESTART_CRON" | awk '{print $2}')
    RESTART_MIN=$(echo "$RESTART_CRON" | awk '{print $1}')
    
    # Format time display
    if [ "$RESTART_HOUR" -eq 0 ] && [ "$RESTART_MIN" -eq 0 ]; then
      TIME_DISPLAY="midnight"
    elif [ "$RESTART_HOUR" -lt 12 ]; then
      TIME_DISPLAY="${RESTART_HOUR}:$(printf '%02d' $RESTART_MIN) AM"
    elif [ "$RESTART_HOUR" -eq 12 ]; then
      TIME_DISPLAY="${RESTART_HOUR}:$(printf '%02d' $RESTART_MIN) PM"
    else
      TIME_DISPLAY="$((RESTART_HOUR - 12)):$(printf '%02d' $RESTART_MIN) PM"
    fi
    
    echo -e "${BLUE}  â†’ Every 3 days at ${TIME_DISPLAY}${NC}"
    
    # Calculate time until next restart (approximate - shows next midnight)
    CURRENT_DAY=$(date +%d | sed 's/^0//')
    CURRENT_HOUR=$(date +%H)
    CURRENT_MIN=$(date +%M)
    CURRENT_TIME_MIN=$((CURRENT_HOUR * 60 + CURRENT_MIN))
    
    # Find next restart day (cron runs on days: 3, 6, 9, 12, 15, 18, 21, 24, 27, 30)
    NEXT_RESTART_DAY=0
    for day in 3 6 9 12 15 18 21 24 27 30; do
      if [ $day -gt $CURRENT_DAY ]; then
        NEXT_RESTART_DAY=$day
        break
      fi
    done
    
    if [ $NEXT_RESTART_DAY -eq 0 ]; then
      # Next restart is day 3 of next month
      DAYS_IN_MONTH=$(date -d "$(date +%Y-%m-01) +1 month -1 day" +%d 2>/dev/null || date -d "$(date +%Y-%m)-01 +1 month -1 day" +%d)
      DAYS_UNTIL=$((DAYS_IN_MONTH - CURRENT_DAY + 3))
    else
      DAYS_UNTIL=$((NEXT_RESTART_DAY - CURRENT_DAY))
    fi
    
    # Adjust for current time
    if [ $CURRENT_TIME_MIN -eq 0 ]; then
      echo -e "${BLUE}  â†’ Next run in: ${DAYS_UNTIL} days, <1m${NC}"
    elif [ $CURRENT_TIME_MIN -gt 0 ]; then
      DAYS_UNTIL=$((DAYS_UNTIL - 1))
      MINUTES_UNTIL=$((1440 - CURRENT_TIME_MIN))
      HOURS_UNTIL=$((MINUTES_UNTIL / 60))
      MINS_UNTIL=$((MINUTES_UNTIL % 60))
      echo -e "${BLUE}  â†’ Next run in: ${DAYS_UNTIL} days, ${HOURS_UNTIL}h ${MINS_UNTIL}m${NC}"
    fi
  else
    echo -e "${YELLOW}Auto-restart: DISABLED âœ—${NC}"
  fi
  
  echo ""
  echo -e "${BOLD}${CYAN}Server Details:${NC}"
  
  if [ -d "$BASE_DIR" ]; then
    # Get port from config if exists
    if [ -f "$BASE_DIR/config.json" ] && command -v jq >/dev/null 2>&1; then
      SERVER_PORT=$(jq -r '.server.port // empty' "$BASE_DIR/config.json" 2>/dev/null || echo "$PORT")
    else
      SERVER_PORT="$PORT"
    fi
    
    SERVER_IP=$(hostname -I | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -n1)
    
    echo -e "${BOLD}${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BLUE}IP Address:      ${BOLD}${SERVER_IP}:${SERVER_PORT}${NC}"
    echo -e "${BLUE}Directory:       ${BASE_DIR}${NC}"
    
    # Disk usage
    if [ -d "$BASE_DIR" ]; then
      DISK_USAGE=$(du -sh "$BASE_DIR" 2>/dev/null | cut -f1)
      echo -e "${BLUE}Disk Usage:      ${DISK_USAGE}${NC}"
    fi
    
    # Backup count and size
    if [ -d "$BACKUP_DIR" ]; then
      BACKUP_COUNT=$(ls -1 "$BACKUP_DIR"/hytale-backup-*.tar.gz 2>/dev/null | wc -l)
      if [ $BACKUP_COUNT -gt 0 ]; then
        BACKUP_SIZE=$(du -sh "$BACKUP_DIR" 2>/dev/null | cut -f1)
        echo -e "${BLUE}Backups:         ${BACKUP_COUNT} (${BACKUP_SIZE})${NC}"
        
        # Show latest backup date
        LATEST_BACKUP=$(ls -t "$BACKUP_DIR"/hytale-backup-*.tar.gz 2>/dev/null | head -1)
        if [ -n "$LATEST_BACKUP" ]; then
          BACKUP_DATE=$(stat -c %y "$LATEST_BACKUP" 2>/dev/null | cut -d' ' -f1)
          echo -e "${BLUE}Latest Backup:   ${BACKUP_DATE}${NC}"
        fi
      else
        echo -e "${YELLOW}Backups:         None${NC}"
      fi
    fi
    
    # Auth status
    if [ -f "$BASE_DIR/auth.enc" ]; then
      echo -e "${GREEN}Authentication:  CONFIGURED âœ“${NC}"
    else
      echo -e "${YELLOW}Authentication:  PENDING âš ${NC}"
    fi
    
    # Log count
    if [ -d "$BASE_DIR/logs" ]; then
      LOG_COUNT=$(find "$BASE_DIR/logs" -name "*.log" -type f 2>/dev/null | wc -l)
      if [ $LOG_COUNT -gt 0 ]; then
        echo -e "${BLUE}Log Files:       ${LOG_COUNT}${NC}"
      fi
    fi
    
    echo -e "${BOLD}${CYAN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  fi
  
  echo ""
  echo -e "${GREEN}===========================================${NC}"
}

# View server logs
view_logs() {
  echo ""
  
  if [ ! -d "$BASE_DIR/logs" ]; then
    echo -e "${RED}Error: Logs directory not found.${NC}"
    echo -e "${YELLOW}Has the server been started yet?${NC}"
    exit 1
  fi
  
  LATEST_LOG=$(ls -t "$BASE_DIR/logs"/*.log 2>/dev/null | head -1)
  
  if [ -z "$LATEST_LOG" ]; then
    echo -e "${RED}Error: No log files found.${NC}"
    exit 1
  fi
  
  echo -e "${CYAN}Viewing latest log: $(basename "$LATEST_LOG")${NC}"
  echo -e "${YELLOW}Press Ctrl+C to stop${NC}"
  echo ""
  sleep 2
  
  tail -f "$LATEST_LOG"
}

# Start server function
start_server() {
  echo ""
  echo -e "${CYAN}Starting Hytale server...${NC}"
  
  if [ ! -f "$BASE_DIR/start.sh" ]; then
    echo -e "${RED}ERROR: Hytale server is not installed.${NC}"
    echo -e "${YELLOW}Please install it first.${NC}"
    exit 1
  fi
  
  if is_server_running; then
    echo -e "${YELLOW}Server is already running.${NC}"
    exit 0
  fi
  
  # Start server in background
  "$BASE_DIR/start.sh" &
  sleep 3
  
  if is_server_running; then
    # Wait for authentication URL if auth.enc doesn't exist
    if [ ! -f "$BASE_DIR/auth.enc" ]; then
      sleep 8
      
      # Check for auth URL in logs
      if [ -d "$BASE_DIR/logs" ]; then
        LATEST_LOG=$(ls -t "$BASE_DIR/logs"/*.log 2>/dev/null | head -1)
        if [ -n "$LATEST_LOG" ]; then
          AUTH_URL=$(grep -oP 'https://oauth\.accounts\.hytale\.com/oauth2/device/verify\?user_code=[A-Za-z0-9]+' "$LATEST_LOG" 2>/dev/null | tail -1)
          if [ -n "$AUTH_URL" ]; then
            echo ""
            echo "=========================================="
            echo "ðŸ” AUTHENTICATION REQUIRED"
            echo "ðŸ”— Visit: $AUTH_URL"
            echo "=========================================="
            echo ""
          fi
        fi
      fi
    fi
    
    echo -e "${GREEN}Hytale server started successfully.${NC}"
    echo -e "${BLUE}Attach to console: $0 console${NC}"
  else
    echo -e "${RED}Failed to start Hytale server.${NC}" >&2
    echo -e "${YELLOW}Check logs with: $0 logs${NC}" >&2
    exit 1
  fi
}

# Restart server function (without systemctl)
restart_server() {
  echo ""
  echo -e "${BOLD}${YELLOW}=== Restarting Hytale Server ===${NC}"
  echo ""
  
  if [ ! -f "$BASE_DIR/start.sh" ]; then
    echo -e "${RED}ERROR: Hytale server is not installed.${NC}"
    exit 1
  fi
  
  SERVER_WAS_RUNNING=false
  if is_server_running; then
    SERVER_WAS_RUNNING=true
    echo -e "${CYAN}[1/2]${NC} Stopping server..."
    tmux kill-session -t hytale-server 2>/dev/null || true
    
    # Wait for clean shutdown
    for i in {1..15}; do
      if ! is_server_running; then
        break
      fi
      sleep 1
    done
    
    echo -e "${GREEN}âœ“ Server stopped${NC}"
  else
    echo -e "${YELLOW}Server was not running${NC}"
  fi
  
  echo -e "${CYAN}[2/2]${NC} Starting server..."
  "$BASE_DIR/start.sh" &
  sleep 3
  
  if is_server_running; then
    echo -e "${GREEN}âœ“ Server restarted successfully${NC}"
    echo ""
    echo -e "${BLUE}Attach to console: $0 console${NC}"
  else
    echo -e "${RED}Failed to restart server${NC}" >&2
    exit 1
  fi
  
  echo ""
  echo -e "${GREEN}===========================================${NC}"
}

# Stop server function
stop_server() {
  echo ""
  echo -e "${CYAN}Stopping Hytale server...${NC}"
  
  if [ ! -f "$BASE_DIR/start.sh" ]; then
    echo -e "${RED}ERROR: Hytale server is not installed.${NC}"
    exit 1
  fi
  
  if ! is_server_running; then
    echo -e "${YELLOW}Server is not running.${NC}"
    exit 0
  fi
  
  tmux kill-session -t hytale-server 2>/dev/null || true
  
  # Wait for clean shutdown
  for i in {1..10}; do
    if ! is_server_running; then
      break
    fi
    sleep 1
  done
  
  if ! is_server_running; then
    echo -e "${GREEN}Hytale server stopped.${NC}"
  else
    echo -e "${YELLOW}Server may still be shutting down...${NC}"
  fi
}

# Console attachment function
attach_console() {
  echo ""
  if ! tmux has-session -t hytale-server 2>/dev/null; then
    echo -e "${RED}Error: Hytale server console session not found.${NC}"
    echo -e "${YELLOW}Is the server running? Check with: $0 status${NC}"
    exit 1
  fi
  
  echo -e "${CYAN}Attaching to Hytale server console...${NC}"
  echo -e "${YELLOW}Press Ctrl+B then D to detach${NC}"
  sleep 2
  tmux attach -t hytale-server
}

# Configuration editor function
edit_config() {
  echo ""
  echo -e "${BOLD}${CYAN}=== Server Configuration Editor ===${NC}"
  echo ""
  
  if [ ! -f "$BASE_DIR/config.json" ]; then
    echo -e "${RED}Error: config.json not found${NC}"
    echo -e "${YELLOW}Has the server been started at least once?${NC}"
    exit 1
  fi
  
  # Create backup of config
  cp "$BASE_DIR/config.json" "$BASE_DIR/config.json.bak"
  echo -e "${GREEN}âœ“ Config backup created: config.json.bak${NC}"
  echo ""
  
  # Determine editor
  if command -v nano >/dev/null 2>&1; then
    EDITOR="nano"
  elif command -v vi >/dev/null 2>&1; then
    EDITOR="vi"
  else
    echo -e "${RED}No text editor found (nano or vi)${NC}"
    exit 1
  fi
  
  echo -e "${YELLOW}Opening config in $EDITOR...${NC}"
  echo -e "${BLUE}Tip: Server should be stopped before editing config${NC}"
  echo ""
  sleep 2
  
  $EDITOR "$BASE_DIR/config.json"
  
  # Set secure permissions
  set_secure_permissions "$BASE_DIR/config.json" 644
  
  echo ""
  echo -e "${GREEN}Configuration edited${NC}"
  echo -e "${YELLOW}Restart server for changes to take effect${NC}"
}

# Log rotation function
rotate_logs() {
  echo ""
  echo -e "${BOLD}${CYAN}=== Log Rotation ===${NC}"
  echo ""
  
  LOGS_DIR="$BASE_DIR/logs"
  
  if [ ! -d "$LOGS_DIR" ]; then
    echo -e "${YELLOW}No logs directory found${NC}"
    exit 0
  fi
  
  # Count log files
  LOG_COUNT=$(find "$LOGS_DIR" -name "*.log" -type f 2>/dev/null | wc -l)
  
  if [ "$LOG_COUNT" -eq 0 ]; then
    echo -e "${YELLOW}No log files found${NC}"
    exit 0
  fi
  
  # Calculate total size
  TOTAL_SIZE=$(du -sh "$LOGS_DIR" 2>/dev/null | cut -f1)
  
  echo -e "${BLUE}Current logs: $LOG_COUNT files ($TOTAL_SIZE)${NC}"
  echo ""
  
  echo -e "${YELLOW}Choose rotation option:${NC}"
  echo -e "  ${BOLD}1${NC} - Compress logs older than 7 days"
  echo -e "  ${BOLD}2${NC} - Delete logs older than 30 days"
  echo -e "  ${BOLD}3${NC} - Delete all logs except latest"
  echo -e "  ${BOLD}4${NC} - Cancel"
  echo ""
  
  read -p "Select option (1-4): " OPTION
  
  case "$OPTION" in
    1)
      echo -e "${CYAN}Compressing logs older than 7 days...${NC}"
      COMPRESSED=0
      while IFS= read -r log_file; do
        if [ -f "$log_file" ] && [ ! -f "${log_file}.gz" ]; then
          gzip "$log_file"
          COMPRESSED=$((COMPRESSED + 1))
        fi
      done < <(find "$LOGS_DIR" -name "*.log" -type f -mtime +7)
      
      if [ $COMPRESSED -gt 0 ]; then
        echo -e "${GREEN}âœ“ Compressed $COMPRESSED log file(s)${NC}"
      else
        echo -e "${YELLOW}No logs to compress${NC}"
      fi
      ;;
    2)
      echo -e "${CYAN}Deleting logs older than 30 days...${NC}"
      DELETED=$(find "$LOGS_DIR" -name "*.log" -o -name "*.log.gz" -type f -mtime +30 -delete -print | wc -l)
      
      if [ $DELETED -gt 0 ]; then
        echo -e "${GREEN}âœ“ Deleted $DELETED log file(s)${NC}"
      else
        echo -e "${YELLOW}No old logs to delete${NC}"
      fi
      ;;
    3)
      echo -e "${YELLOW}WARNING: This will delete all logs except the most recent!${NC}"
      read -p "Are you sure? (yes/no): " CONFIRM
      
      if [ "$CONFIRM" = "yes" ]; then
        LATEST_LOG=$(ls -t "$LOGS_DIR"/*.log 2>/dev/null | head -1)
        find "$LOGS_DIR" -name "*.log" -o -name "*.log.gz" -type f ! -path "$LATEST_LOG" -delete
        echo -e "${GREEN}âœ“ Old logs deleted${NC}"
      else
        echo -e "${YELLOW}Cancelled${NC}"
      fi
      ;;
    4)
      echo -e "${YELLOW}Cancelled${NC}"
      exit 0
      ;;
    *)
      echo -e "${RED}Invalid option${NC}"
      exit 1
      ;;
  esac
  
  # Show new stats
  NEW_COUNT=$(find "$LOGS_DIR" -name "*.log" -o -name "*.log.gz" -type f 2>/dev/null | wc -l)
  NEW_SIZE=$(du -sh "$LOGS_DIR" 2>/dev/null | cut -f1)
  
  echo ""
  echo -e "${GREEN}After rotation: $NEW_COUNT files ($NEW_SIZE)${NC}"
  echo -e "${GREEN}===========================================${NC}"
}

# Mods management function
manage_mods() {
  local action=$1
  local mod_name=$2
  
  # Ensure mods directory exists
  mkdir -p "$MODS_DIR"
  
  case "$action" in
    list)
      echo ""
      echo -e "${BOLD}${CYAN}=== Available Mods ===${NC}"
      echo ""
      
      if [ ${#MOD_URLS[@]} -eq 0 ]; then
        echo -e "${YELLOW}No mods defined yet${NC}"
        echo -e "${BLUE}Add mods to the MOD_URLS array in the script${NC}"
        return
      fi
      
      # List available mods
      echo -e "${CYAN}Available for installation:${NC}"
      local index=1
      local -a mod_array=()
      for mod in "${!MOD_URLS[@]}"; do
        mod_array+=("$mod")
      done
      # Sort array
      IFS=$'\n' mod_array=($(sort <<<"${mod_array[*]}"))
      unset IFS
      
      for mod in "${mod_array[@]}"; do
        if [ -f "$MODS_DIR/${mod}.jar" ]; then
          echo -e "  ${BOLD}[$index]${NC} ${GREEN}âœ“${NC} ${BOLD}$mod${NC} ${YELLOW}(installed)${NC}"
        else
          echo -e "  ${BOLD}[$index]${NC} ${BLUE}â—‹${NC} ${BOLD}$mod${NC}"
        fi
        ((index++))
      done
      
      # List installed mods not in the list
      echo ""
      echo -e "${CYAN}Installed mods:${NC}"
      if [ -d "$MODS_DIR" ] && [ "$(ls -A "$MODS_DIR"/*.jar 2>/dev/null)" ]; then
        for jar in "$MODS_DIR"/*.jar; do
          jar_name=$(basename "$jar")
          jar_size=$(du -h "$jar" | cut -f1)
          echo -e "  ${GREEN}â€¢${NC} $jar_name ${BLUE}($jar_size)${NC}"
        done
      else
        echo -e "  ${YELLOW}No mods installed${NC}"
      fi
      
      echo ""
      echo -e "${GREEN}===========================================${NC}"
      ;;
      
    install)
      if [ -z "$mod_name" ]; then
        echo -e "${RED}Error: Mod name or number required${NC}"
        echo -e "${YELLOW}Usage: $0 mods install <mod-name|number>${NC}"
        echo ""
        echo -e "${CYAN}Available mods:${NC}"
        local index=1
        local -a mod_array=()
        for mod in "${!MOD_URLS[@]}"; do
          mod_array+=("$mod")
        done
        IFS=$'\n' mod_array=($(sort <<<"${mod_array[*]}"))
        unset IFS
        for mod in "${mod_array[@]}"; do
          echo -e "  ${BOLD}[$index]${NC} $mod"
          ((index++))
        done
        exit 1
      fi
      
      # Check if input is a number
      if [[ "$mod_name" =~ ^[0-9]+$ ]]; then
        # Input is a number, get mod name by index
        local -a mod_array=()
        for mod in "${!MOD_URLS[@]}"; do
          mod_array+=("$mod")
        done
        IFS=$'\n' mod_array=($(sort <<<"${mod_array[*]}"))
        unset IFS
        
        local index=$((mod_name - 1))
        if [ $index -lt 0 ] || [ $index -ge ${#mod_array[@]} ]; then
          echo -e "${RED}Error: Invalid mod number '$mod_name'${NC}"
          echo -e "${YELLOW}Please choose a number between 1 and ${#mod_array[@]}${NC}"
          exit 1
        fi
        mod_name="${mod_array[$index]}"
      fi
      
      # Check if mod exists in list
      if [ -z "${MOD_URLS[$mod_name]}" ]; then
        echo -e "${RED}Error: Mod '$mod_name' not found${NC}"
        echo ""
        echo -e "${CYAN}Available mods:${NC}"
        local index=1
        local -a mod_array=()
        for mod in "${!MOD_URLS[@]}"; do
          mod_array+=("$mod")
        done
        IFS=$'\n' mod_array=($(sort <<<"${mod_array[*]}"))
        unset IFS
        for mod in "${mod_array[@]}"; do
          echo -e "  ${BOLD}[$index]${NC} $mod"
          ((index++))
        done
        exit 1
      fi
      
      # Check if already installed
      if [ -f "$MODS_DIR/${mod_name}.jar" ]; then
        echo -e "${YELLOW}Mod '$mod_name' is already installed${NC}"
        read -p "Reinstall? (yes/no): " REINSTALL
        if [ "$REINSTALL" != "yes" ]; then
          echo -e "${YELLOW}Installation cancelled${NC}"
          exit 0
        fi
      fi
      
      echo ""
      echo -e "${BOLD}${CYAN}=== Installing Mod: $mod_name ===${NC}"
      echo ""
      
      echo -e "${CYAN}[1/3]${NC} Preparing installation..."
      # Download mod
      MOD_URL="${MOD_URLS[$mod_name]}"
      MOD_FILE="${mod_name}.jar"
      MOD_PATH="$MODS_DIR/$MOD_FILE"
      
      echo -e "${CYAN}[2/3]${NC} Downloading mod..."
      echo -e "${BLUE}Source: $MOD_URL${NC}"
      
      if curl -L "$MOD_URL" -o "$MOD_PATH" --progress-bar; then
        echo -e "${CYAN}[3/3]${NC} Verifying installation..."
        # Verify download
        if [ -f "$MOD_PATH" ] && [ -s "$MOD_PATH" ]; then
          MOD_SIZE=$(du -h "$MOD_PATH" | cut -f1)
          echo ""
          echo -e "${GREEN}==========================================${NC}"
          echo -e "${GREEN}âœ“ Mod installed successfully!${NC}"
          echo -e "${BLUE}Location: $MOD_PATH${NC}"
          echo -e "${BLUE}Size: $MOD_SIZE${NC}"
          echo -e "${GREEN}==========================================${NC}"
          echo ""
          echo -e "${YELLOW}Restart server for changes to take effect${NC}"
        else
          echo -e "${RED}Downloaded file is empty or invalid${NC}"
          rm -f "$MOD_PATH"
          exit 1
        fi
      else
        echo -e "${RED}Failed to download mod${NC}"
        rm -f "$MOD_PATH"
        exit 1
      fi
      ;;
      
    uninstall)
      if [ -z "$mod_name" ]; then
        echo -e "${RED}Error: Mod name or number required${NC}"
        echo -e "${YELLOW}Usage: $0 mods uninstall <mod-name|number>${NC}"
        exit 1
      fi
      
      # Check if input is a number
      if [[ "$mod_name" =~ ^[0-9]+$ ]]; then
        # Input is a number, get mod name by index
        local -a mod_array=()
        for mod in "${!MOD_URLS[@]}"; do
          mod_array+=("$mod")
        done
        IFS=$'\n' mod_array=($(sort <<<"${mod_array[*]}"))
        unset IFS
        
        local index=$((mod_name - 1))
        if [ $index -lt 0 ] || [ $index -ge ${#mod_array[@]} ]; then
          echo -e "${RED}Error: Invalid mod number '$mod_name'${NC}"
          echo -e "${YELLOW}Please choose a number between 1 and ${#mod_array[@]}${NC}"
          exit 1
        fi
        mod_name="${mod_array[$index]}"
      fi
      
      # Set mod filename
      MOD_FILE="${mod_name}.jar"
      MOD_PATH="$MODS_DIR/$MOD_FILE"
      
      if [ ! -f "$MOD_PATH" ]; then
        echo -e "${RED}Error: Mod '$mod_name' is not installed${NC}"
        echo ""
        echo -e "${CYAN}Installed mods:${NC}"
        if [ -d "$MODS_DIR" ] && [ "$(ls -A "$MODS_DIR"/*.jar 2>/dev/null)" ]; then
          for jar in "$MODS_DIR"/*.jar; do
            echo -e "  - $(basename "$jar" .jar)"
          done
        else
          echo -e "  ${YELLOW}No mods installed${NC}"
        fi
        exit 1
      fi
      
      echo ""
      echo -e "${BOLD}${YELLOW}=== Uninstalling Mod: $mod_name ===${NC}"
      echo ""
      
      echo -e "${CYAN}[1/2]${NC} Confirming uninstallation..."
      read -p "Are you sure? (yes/no): " CONFIRM
      
      if [ "$CONFIRM" = "yes" ]; then
        echo -e "${CYAN}[2/2]${NC} Removing mod..."
        rm -f "$MOD_PATH"
        echo ""
        echo -e "${GREEN}==========================================${NC}"
        echo -e "${GREEN}âœ“ Mod uninstalled successfully!${NC}"
        echo -e "${GREEN}==========================================${NC}"
        echo ""
        echo -e "${YELLOW}Restart server for changes to take effect${NC}"
      else
        echo -e "${YELLOW}Uninstall cancelled${NC}"
      fi
      ;;
      
    *)
      echo -e "${RED}Error: Invalid action '$action'${NC}"
      echo ""
      echo -e "${YELLOW}Usage:${NC}"
      echo -e "  $0 mods list                    - List available and installed mods"
      echo -e "  $0 mods install <mod-name>      - Install a mod"
      echo -e "  $0 mods uninstall <mod-name>    - Uninstall a mod"
      exit 1
      ;;
  esac
}

# Show usage information
show_usage() {
  echo -e "${CYAN}Hytale Dedicated Server Manager${NC}"
  echo ""
  echo "Usage: $0 [command] [options]"
  echo ""
  echo "Commands:"
  echo "  install      - Install Hytale server"
  echo "  start        - Start Hytale server"
  echo "                 Options: --skip-auth (skip authentication wait)"
  echo "  stop         - Stop Hytale server"
  echo "  restart      - Restart Hytale server"
  echo "  update       - Update Hytale server"
  echo "  uninstall    - Uninstall Hytale server"
  echo "  status       - Show server status and configuration"
  echo "  console      - Attach to server console"
  echo "  logs         - View server logs (live tail)"
  echo "  rotate-logs  - Manage and rotate server logs"
  echo "  backup       - Create manual backup"
  echo "  restore      - Restore from backup"
  echo "  config       - Edit server configuration"
  echo "  autobackup   - Toggle automatic backups"
  echo "  autorestart  - Toggle automatic restarts"
  echo ""
  echo "Mods Management:"
  echo "  mods list                - List available and installed mods"
  echo "  mods install <name>      - Install a mod"
  echo "  mods uninstall <name>    - Uninstall a mod"
  echo ""
  echo "Run without arguments to show this help."
}

# ================= MAIN =================
# Parse command line arguments
if [ $# -eq 0 ]; then
  # No arguments, show interactive menu
  show_usage
else
  # Handle command line argument
  case "$1" in
    install)
      install_server
      ;;
    start)
      start_server "$@"
      ;;
    stop)
      stop_server
      ;;
    restart)
      restart_server
      ;;
    update)
      update_server
      ;;
    uninstall)
      uninstall_server
      ;;
    console)
      attach_console
      ;;
    backup)
      backup_server
      ;;
    restore)
      restore_server
      ;;
    config)
      edit_config
      ;;
    rotate-logs)
      rotate_logs
      ;;
    autobackup)
      toggle_autobackup
      ;;
    autorestart)
      toggle_autorestart
      ;;
    mods)
      manage_mods "$2" "$3"
      ;;
    status)
      show_status
      ;;
    logs)
      view_logs
      ;;
    help|--help|-h)
      show_usage
      ;;
    *)
      echo -e "${RED}Error: Unknown command '$1'${NC}"
      echo ""
      show_usage
      exit 1
      ;;
  esac
fi